---
title: ECE2050-Chapter9
published: 2025-08-24
updated: 2025-08-24
description: ''
tags: [ECE2050]
category: 学习
---

好的，这份中文自学讲义根据您提供的PPT内容编写而成，旨在帮助您深入理解数字逻辑与系统中的“有限状态机”章节。讲义包含了PPT中的所有核心概念，并增加了详细的解释和说明，以便于自学。

---

### **ECE 2050 数字逻辑与系统**
### **第 9 章：有限状态机 (Finite State Machine)**
**讲师：Yue ZHENG, Ph.D.**
**香港中文大学（深圳）**

---

### **第一部分：同步时序设计 (Synchronous Sequential Design)**

#### **1. 上周内容回顾**

在深入本章内容之前，我们先简单回顾一下上周学习的知识点：
*   **移位寄存器 (Shift Registers)**
    *   数据存储与数据移动
    *   串行/并行输入 - 串行/并行输出
*   **双向移位寄存器 (Bidirectional Shift Registers)**
*   **移位寄存器应用**
    *   时间延迟
    *   串并数据转换器
    *   通用异步收发器 (UART)
    *   键盘编码器
*   **约翰逊计数器 (Johnson Counter) & 环形计数器 (Ring Counter)**

这些内容是学习本章的基础，因为它们都属于时序逻辑电路。

#### **2. 什么是时序逻辑 (Sequential Logic)**

*   **定义**：简单来说，所有不是组合逻辑 (Combinational) 的电路都属于时序逻辑电路。组合逻辑的输出仅取决于当前的输入，而时序逻辑的输出不仅取决于当前输入，还与电路之前的状态有关（即具有记忆功能）。

*   **一个有问题的电路示例**：
    

    上图展示了一个由三个反相器组成的环路。我们来分析它的特性：
    *   **没有外部输入，却有输出**：这个电路没有明确的输入信号。
    *   **非稳态电路，会振荡 (oscillates)**：假设X点的初始状态是0，经过第一个反相器后Y点变为1，再经过第二个反相器后Z点变为0，最后Z点的0反馈给X点，这似乎是稳定的。但实际上，信号通过门电路需要时间（门延迟）。当Z的输出（新的X）反馈到输入端时，会引起状态的连锁变化，导致X, Y, Z的电平不断地高低翻转，形成振荡。
    *   **周期取决于反相器延迟**：振荡的频率（周期）由信号通过这三个反相器的总延迟时间决定。
    *   **存在循环路径 (cyclic path)**：电路的最终输出被反馈回了输入端，形成了一个闭环。

这种不稳定的、行为难以预测的循环路径在数字设计中通常是需要避免的。

#### **3. 同步时序逻辑设计 (Synchronous Sequential Logic Design)**

为了解决上述问题并构建出行为可控、稳定可靠的时序电路，我们引入了**同步设计**思想。

*   **核心思想**：通过**插入寄存器 (inserting registers)** 来打破循环路径。
*   **状态 (State)**：寄存器中存储的值代表了系统的当前“状态”。
*   **同步 (Synchronized)**：所有状态的变化都只在时钟信号 (clock) 的特定边沿（例如上升沿）发生。整个系统都由同一个时钟信号来协调、同步。

**同步时序电路的设计规则：**
1.  电路中每个元件要么是**寄存器**，要么是**组合逻辑电路**。
2.  电路中**至少要有一个**元件是寄存器（以实现记忆功能）。
3.  所有寄存器都接收**完全相同**的时钟信号。
4.  每一个循环路径都**必须包含至少一个寄存器**。这可以防止信号在单个时钟周期内无限振荡。

**有限状态机 (Finite State Machine, FSM)** 是最常见、最重要的一种同步时序电路。

---

### **第二部分：有限状态机 (Finite State Machine, FSM)**

#### **1. FSM 的基本构成**

一个标准的 FSM 由两大部分组成：

1.  **状态寄存器 (State register)**
    *   **作用**：存储 FSM 的**当前状态 (Current State)**。
    *   **工作方式**：在每个时钟边沿，它会加载并更新为**下一个状态 (Next State)**。
    

2.  **组合逻辑 (Combinational logic)**
    *   **作用**：它被分为两个部分：
        *   **下一状态逻辑 (Next State Logic)**：根据**当前状态**和**外部输入**，计算出下一个时钟周期应该进入的状态。
        *   **输出逻辑 (Output Logic)**：根据**当前状态**（有时也包括**外部输入**）计算出 FSM 的**当前输出**。
    

#### **2. FSM 的两种类型：Moore 与 Mealy**

FSM 的下一个状态总是由“当前状态”和“输入”共同决定。但根据**输出的决定方式**不同，FSM 可以分为两种类型：

*   **Moore 型 FSM (Moore FSM)**
    *   **定义**：输出**仅仅**取决于**当前状态**。
    *   **特点**：无论输入如何变化，只要状态不变，输出就保持不变。输出的变化会比状态变化延迟一个时钟周期。
    *   **结构图**：
        
        从图中可以看出，输出逻辑 (output logic) 的输入只来自状态寄存器 (state)，与外部输入 (inputs) 无关。

*   **Mealy 型 FSM (Mealy FSM)**
    *   **定义**：输出由**当前状态**和**当前输入**共同决定。
    *   **特点**：输入信号的变化可以立即（在同一个时钟周期内）引起输出的变化，而无需等待下一个状态。这使得 Mealy FSM 的响应通常比 Moore FSM 更快。

#### **3. FSM 的标准设计流程**

设计一个 FSM 通常遵循以下七个步骤：

1.  **识别输入和输出 (Identify inputs and outputs)**：明确 FSM 需要接收哪些输入信号，以及需要产生哪些输出信号。
2.  **绘制状态转移图 (Sketch state transition diagram)**：用图形化的方式描述 FSM 的行为。图中包含状态（圆圈）和状态之间的转换条件（箭头）。
3.  **编写状态转移表和输出表 (Write state transition table and output table)**：将状态转移图用表格的形式精确地描述出来。
    *   对于 **Moore FSM**，通常写成两个独立的表：一个状态转移表和一个输出表。
    *   对于 **Mealy FSM**，通常将状态转移和输出合并在一个表中，因为输出与转移条件（输入）直接相关。
4.  **选择状态编码 (Select state encodings)**：为每个抽象的状态（如 S0, S1）分配一个唯一的二进制代码。
5.  **重写带有状态编码的转移表和输出表 (Rewrite tables with state encodings)**：将表中的抽象状态替换为二进制编码。
6.  **写出下一状态和输出逻辑的布尔方程 (Write Boolean equations)**：根据编码后的表格，为下一状态的每一位和输出的每一位推导出逻辑表达式。
7.  **绘制电路原理图 (Sketch the circuit schematic)**：根据布尔方程，用逻辑门和触发器（寄存器）画出最终的电路图。

---

### **第三部分：Moore FSM 设计实例 - 交通灯控制器**

让我们通过一个具体的例子来实践上述设计流程。

**设计目标**：为一个十字路口的交通灯设计一个控制器。

#### **步骤 1：识别输入和输出**

*   **场景**：十字路口有两条路，主干道 (Academic Ave.) 和次干道 (Bravado Blvd.)。
*   **输入**：
    *   `TA`：主干道车辆传感器。当主干道有车时为 `TRUE` (1)。
    *   `TB`：次干道车辆传感器。当次干道有车时为 `TRUE` (1)。
    *   （此外还有 `CLK` 时钟和 `Reset` 复位信号）。
*   **输出**：
    *   `LA`：主干道的交通灯（绿、黄、红）。
    *   `LB`：次干道的交通灯（绿、黄、红）。


#### **步骤 2：绘制状态转移图**

我们需要定义 FSM 的状态。每个状态对应交通灯的一种特定组合。
*   **S0 (主绿次红)**：主干道绿灯，次干道红灯。这是默认状态。
*   **S1 (主黄次红)**：主干道黄灯，次干道红灯。准备切换。
*   **S2 (主红次绿)**：主干道红灯，次干道绿灯。
*   **S3 (主红次黄)**：主干道红灯，次干道黄灯。准备切换。

**转移逻辑**：
*   在 **S0** 状态，如果主干道一直有车 (`TA=1`)，则保持绿灯；如果主干道没车了 (`TA=0`)，则切换到黄灯状态 **S1**，准备让行。
*   在 **S1** 状态，黄灯持续一个时钟周期后，无条件切换到 **S2**。
*   在 **S2** 状态，如果次干道一直有车 (`TB=1`)，则保持绿灯；如果次干道没车了 (`TB=0`)，则切换到黄灯状态 **S3**。
*   在 **S3** 状态，黄灯持续一个时钟周期后，无条件切换回 **S0**。
*   **Reset** 信号会强制 FSM 回到初始状态 **S0**。


**注意**：这是一个 Moore FSM，所以输出（灯的颜色）被标记在状态（圆圈）的内部。

#### **步骤 3 & 5：编写（编码后）状态转移表和输出表**

首先，我们需要对状态和输出进行二进制编码。

| **状态** | **二进制编码 (S1 S0)** |
| :--- | :--- |
| S0 | 00 |
| S1 | 01 |
| S2 | 10 |
| S3 | 11 |

| **灯光输出** | **二进制编码** |
| :--- | :--- |
| 绿 (green) | 00 |
| 黄 (yellow) | 01 |
| 红 (red) | 10 |

**状态转移表（已编码）**：(S' 代表下一状态)
`X` 表示“不关心 (don't care)”，即该输入不影响此次状态转移。

| 当前状态 (S1 S0) | 输入 (TA, TB) | 下一状态 (S'1 S'0) |
| :--- |:--- | :--- |
| 00 (S0) | `TA=0`, `TB=X` | 01 (S1) |
| 00 (S0) | `TA=1`, `TB=X` | 00 (S0) |
| 01 (S1) | `TA=X`, `TB=X` | 10 (S2) |
| 10 (S2) | `TA=X`, `TB=0` | 11 (S3) |
| 10 (S2) | `TA=X`, `TB=1` | 10 (S2) |
| 11 (S3) | `TA=X`, `TB=X` | 00 (S0) |

**输出表（已编码）**：(LA1 LA0 代表 A 路灯，LB1 LB0 代表 B 路灯)

| 当前状态 (S1 S0) | LA 输出 | LB 输出 | LA 编码 (LA1 LA0) | LB 编码 (LB1 LB0) |
| :--- | :--- | :--- | :--- | :--- |
| 00 (S0) | 绿 (green) | 红 (red) | 00 | 10 |
| 01 (S1) | 黄 (yellow) | 红 (red) | 01 | 10 |
| 10 (S2) | 红 (red) | 绿 (green) | 10 | 00 |
| 11 (S3) | 红 (red) | 黄 (yellow) | 10 | 01 |

#### **步骤 6 & 7：推导布尔方程并绘制电路图**

根据上述表格，我们可以使用卡诺图或其他化简方法来推导出下一状态和输出的逻辑方程。
*   **下一状态方程**：
    *   `S'1 = S1'S0'TA' + S1'S0 + S1S0'TB' + S1S0'TB = ...` (化简后)
    *   `S'0 = S1'S0'TA' + S1S0'TB' = ...` (化简后)
*   **输出方程**：
    *   `LA1 = S1`
    *   `LA0 = S1'S0`
    *   `LB1 = S1'S0' + S1'S0 = S1'`
    *   `LB0 = S1S0`

得到这些方程后，就可以用逻辑门（与门、或门、非门）和两个D触发器（用于存储S1和S0）来构建整个控制器电路。

---

### **第四部分：Moore vs. Mealy FSM 对比实例**

**问题描述**：
Alyssa P. Hacker 有一只蜗牛，它会沿着一条写有 0 和 1 的纸带爬行。每当蜗牛爬过的**最后两位数字是 "01"** 时，它就会微笑。请为这只蜗牛的大脑分别设计一个 Moore FSM 和一个 Mealy FSM 来控制它微笑。
*   **输入 (A)**：纸带上当前的数字 (0 或 1)。
*   **输出 (Y)**：是否微笑 (1 = 微笑, 0 = 不微笑)。

#### **1. Moore FSM 设计**

**状态定义**：状态需要记住“可能构成01”的历史信息。
*   **S0**：初始状态，或者上一个输入是 1 (不构成 "01" 的开头)。
*   **S1**：刚刚看到了一个 0 (可能是 "01" 的开头)。
*   **S2**：刚刚看到了 "01" 序列。**在这个状态下，蜗牛微笑**。

**状态转移图**：

*   输出 `Y` 写在状态内部。只有在 S2 状态时，输出 `Y=1`。

**状态表**：(编码: S0=00, S1=01, S2=10)
| 当前状态 (S1 S0) | 输入 (A) | 下一状态 (S'1 S'0) |
| :--- | :--- | :--- |
| 00 (S0) | 0 | 01 (S1) |
| 00 (S0) | 1 | 00 (S0) |
| 01 (S1) | 0 | 01 (S1) |
| 01 (S1) | 1 | 10 (S2) |
| 10 (S2) | 0 | 01 (S1) |
| 10 (S2) | 1 | 00 (S0) |

**输出表**：
| 当前状态 (S1 S0) | 输出 (Y) |
| :--- | :--- |
| 00 (S0) | 0 |
| 01 (S1) | 0 |
| 10 (S2) | 1 |

**逻辑方程与电路**：
*   **下一状态方程**: S'₁ = S₀A,  S'₀ = A'
*   **输出方程**: Y = S₁


#### **2. Mealy FSM 设计**

**状态定义**：
*   **S0**：初始状态，或上一个输入是 1。
*   **S1**：上一个输入是 0。

**状态转移图**：

*   输出 `Y` 写在状态转移的箭头上，格式为 `输入/输出`。
*   当在 S0 状态接收到输入 1 时，输出为 0。
*   **当在 S1 状态（意味着前一个是0）接收到输入 1 时，输出为 1，因为 "01" 序列形成了**。

**状态与输出表**：(编码: S0=0, S1=1)
| 当前状态 (S0) | 输入 (A) | 下一状态 (S'0) | 输出 (Y) |
| :--- | :--- | :--- | :--- |
| 0 (S0) | 0 | 1 (S1) | 0 |
| 0 (S0) | 1 | 0 (S0) | 0 |
| 1 (S1) | 0 | 1 (S1) | 0 |
| 1 (S1) | 1 | 0 (S0) | 1 |

**逻辑方程与电路**：
*   **下一状态方程**: S'₀ = A'
*   **输出方程**: Y = S₀A
*   注意：输出 Y 的逻辑同时取决于当前状态 S₀ 和输入 A。

#### **3. 性能对比：时序图分析**



观察时序图，特别是在第 3、7、9 个时钟周期：
*   在第 3 周期，输入序列变为 "01"。
    *   **Mealy FSM**：在当前状态是 S1 (前一个是0) 的情况下，输入 A 变为 1，输出 Y **立即**变为 1。
    *   **Moore FSM**：在当前状态是 S1 (前一个是0) 的情况下，输入 A 变为 1，它计算出下一状态是 S2。只有在**下一个时钟周期（第 4 周期）**，当 FSM 进入 S2 状态后，输出 Y 才变为 1。

**结论**：
*   **Mealy FSM**: 当检测到输入模式 "01" 时，**立即**就断言（assert）输出 Y。
*   **Moore FSM**: 当检测到输入模式 "01" 后，需要**延迟一个时钟周期**才断言输出 Y。

Mealy FSM 的响应速度更快，但其输出逻辑更复杂（依赖于输入和状态），并且输出信号可能在时钟周期内出现毛刺（glitch），因为输入的任何变化都可能直接影响输出。Moore FSM 的输出更稳定，只在时钟边沿后才会改变。

---

### **第五部分：时序约束 (Timing Constraints)**

同步时序电路的正确工作依赖于满足严格的时序规则。

#### **1. 触发器的时序参数**

*   **建立时间 (Setup time, `t_setup`)**：在时钟有效边沿**之前**，输入信号 D 必须保持稳定的最短时间。
*   **保持时间 (Hold time, `t_hold`)**：在时钟有效边沿**之后**，输入信号 D 必须保持稳定的最短时间。
*   **孔径时间 (Aperture time, `t_a`)**：建立时间和保持时间的总和 (`t_a = t_setup + t_hold`)，即时钟边沿前后数据必须稳定的时间窗口。
*   **传输延迟 (Propagation delay, `t_pcq`)**：时钟有效边沿之后，输出 Q 保证达到稳定状态所需的**最长时间**。
*   **污染延迟 (Contamination delay, `t_ccq`)**：时钟有效边沿之后，输出 Q 可能开始发生变化所需的**最短时间**。



#### **2. 动态准则 (Dynamic Discipline)**

对于一个由寄存器 R1、组合逻辑和寄存器 R2 构成的路径：

*   信号从 R1 的输出 Q1 出发，经过组合逻辑，到达 R2 的输入 D2。
*   为了让 R2 能在下一个时钟周期正确锁存数据，D2 上的信号必须在时钟边沿的孔径时间内保持稳定。

这引出了两个关键的时序约束：

1.  **建立时间约束 (Setup Time Constraint)**
    *   也称为**周期时间约束 (Cycle Time Constraint)**。
    *   它关心的是信号从 R1 传播到 R2 的**最长路径延迟**。
    *   信号必须在下一个时钟边沿到来**之前**的 `t_setup` 时间点就已经到达并稳定在 D2 输入端。
    *   **公式**: `T_clk ≥ t_pcq(R1) + t_pd(logic) + t_setup(R2)`
        *   `T_clk`: 时钟周期
        *   `t_pcq(R1)`: R1 的传输延迟
        *   `t_pd(logic)`: 组合逻辑的最大延迟（最长路径延迟）
        *   `t_setup(R2)`: R2 的建立时间
    *   这个约束决定了电路能运行的**最高时钟频率** (f_max = 1 / T_clk_min)。

2.  **保持时间约束 (Hold Time Constraint)**
    *   它关心的是信号从 R1 传播到 R2 的**最短路径延迟**。
    *   在同一个时钟边沿，R1 的输出发生变化，这个新数据不能太快地传到 R2，以至于破坏了 R2 对前一个数据的保持时间要求。
    *   **公式**: `t_ccq(R1) + t_cd(logic) ≥ t_hold(R2)`
        *   `t_ccq(R1)`: R1 的污染延迟
        *   `t_cd(logic)`: 组合逻辑的最小延迟（最短路径延迟）
        *   `t_hold(R2)`: R2 的保持时间
    *   **重要性**：**如果保持时间约束不满足，电路在任何频率下都无法可靠工作！** 因为这个问题与时钟速度无关，而是与电路的内部延迟结构有关。

#### **3. 时序分析实例**



**给定参数**:
*   **触发器**: `t_ccq`=30ps, `t_pcq`=50ps, `t_setup`=60ps, `t_hold`=70ps
*   **逻辑门**: `t_cd`=25ps, `t_pd`=35ps

**分析**:
*   **最长路径 (Setup分析)**: 从 B 或 C 出发，经过 3 个逻辑门到达 X'。
    *   `t_pd(logic)` = 3 * `t_pd(gate)` = 3 * 35ps = 105ps
    *   **建立时间约束**: `T_clk ≥ t_pcq + t_pd(logic) + t_setup`
    *   `T_clk ≥ 50ps + 105ps + 60ps = 215ps`
    *   所以，该电路的最小允许时钟周期为 215ps。
*   **最短路径 (Hold分析)**: 从 D 出发，经过 1 个逻辑门到达 Y'。
    *   `t_cd(logic)` = 1 * `t_cd(gate)` = 25ps
    *   **保持时间约束**: `t_ccq + t_cd(logic) ≥ t_hold`
    *   `30ps + 25ps ≥ 70ps`
    *   `55ps ≥ 70ps`  -> **不成立 (FALSE)**

**结论**：该电路存在**保持时间违例 (Hold Time Violation)**。
**如何修复?** 保持时间违例意味着最短路径太“快”了。我们需要在最短路径上（例如 D 到 Y' 的路径上）增加延迟，比如插入几个 Buffer（缓冲器），以确保新数据不会过早到达。

---

### **第六部分：章节复习与小测**

#### **1. 本章回顾**
*   （同步）时序逻辑计数器
*   **有限状态机 (Finite State Machine)**
    *   Moore FSM (输出仅与状态有关)
    *   Mealy FSM (输出与状态和输入都有关)
*   **时序 (Timing)**
    *   建立时间 (Setup time)
    *   保持时间 (Hold time)
    *   孔径时间 (Aperture time)
    *   传输延迟 (Propagation delay)
    *   污染延迟 (Contamination delay)
*   **动态准则 (Dynamic Discipline)**

#### **2. 判断对错 (True/False Quiz)**

1.  **状态机是一个时序电路，它具有有限数量的状态，并按预设的顺序出现。**
    *   **正确 (True)**。这是状态机的基本定义。

2.  **FSM 由一个状态寄存器和组合逻辑组成。**
    *   **正确 (True)**。这是 FSM 的两大核心组成部分。

3.  **对于同步时序电路，所有寄存器接收相同的时钟。**
    *   **正确 (True)**。这是同步设计的核心规则。

4.  **使用独热码 (one-hot encoding) 对 4 个状态进行编码需要 2-bit。**
    *   **错误 (False)**。
    *   **解释**：独热码 (One-hot) 编码中，任何时候只有一位是 1。对 4 个状态进行编码需要 4-bit，例如 `0001`, `0010`, `0100`, `1000`。使用 2-bit (例如 `00`, `01`, `10`, `11`) 的是二进制编码 (Binary encoding)。

5.  **对于 Moore FSM，输出仅取决于当前状态。**
    *   **正确 (True)**。这是 Moore FSM 的定义。

6.  **建立时间是输入信号在时钟有效边沿之前必须保持稳定的最短时间，以确保数据被寄存器正确捕获。**
    *   **正确 (True)**。这是建立时间的精确定义。

7.  **保持时间是输入信号在时钟有效边沿之后必须保持稳定的最短时间，以确保数据被触发器或寄存器可靠地捕获。**
    *   **正确 (True)**。这是保持时间的精确定义。